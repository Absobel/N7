;; produced by cvc4_16.drv ;;
(set-info :smt-lib-version 2.6)
(set-logic AUFBVFPDTNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

(declare-sort liste 1)

(declare-fun liste1 (ty) ty)

(declare-sort a 0)

(declare-fun a1 () ty)

(declare-fun Nil (ty) uni)

;; Nil_sort
  (assert (forall ((a2 ty)) (sort (liste1 a2) (Nil a2))))

(declare-fun Nil1 () (liste a))

(declare-fun Cons (ty uni uni) uni)

;; Cons_sort
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (x1 uni)) (sort (liste1 a2) (Cons a2 x x1)))))

(declare-fun match_liste (ty ty uni uni uni) uni)

;; match_liste_sort
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort a3 (match_liste a3 a2 x x1 x2)))))

(declare-fun t2tb ((liste a)) uni)

;; t2tb_sort
  (assert (forall ((x (liste a))) (sort (liste1 a1) (t2tb x))))

(declare-fun tb2t (uni) (liste a))

;; BridgeL
  (assert
  (forall ((i (liste a))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; match_liste_Nil
  (assert
  (forall ((a2 ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a2 z) (= (match_liste a2 a1 (t2tb Nil1) z z1) z)))))

;; match_liste_Nil
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a3 z) (= (match_liste a3 a2 (Nil a2) z z1) z)))))

;; match_liste_Cons
  (assert
  (forall ((a2 ty) (a3 ty))
  (forall ((z uni) (z1 uni) (u uni) (u1 uni))
  (=> (sort a3 z1) (= (match_liste a3 a2 (Cons a2 u u1) z z1) z1)))))

(declare-fun index_liste (ty uni) Int)

;; index_liste_Nil
  (assert (= (index_liste a1 (t2tb Nil1)) 0))

;; index_liste_Nil
  (assert (forall ((a2 ty)) (= (index_liste a2 (Nil a2)) 0)))

;; index_liste_Cons
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni))
  (! (= (index_liste a2 (Cons a2 u u1)) 1) :pattern ((Cons a2 u u1)) ))))

(declare-fun Cons_proj_1 (ty uni) uni)

;; Cons_proj_1_sort
  (assert (forall ((a2 ty)) (forall ((x uni)) (sort a2 (Cons_proj_1 a2 x)))))

;; Cons_proj_1_def
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni))
  (=> (sort a2 u) (= (Cons_proj_1 a2 (Cons a2 u u1)) u)))))

(declare-fun Cons_proj_2 (ty uni) uni)

;; Cons_proj_2_sort
  (assert
  (forall ((a2 ty)) (forall ((x uni)) (sort (liste1 a2) (Cons_proj_2 a2 x)))))

;; Cons_proj_2_def
  (assert
  (forall ((a2 ty))
  (forall ((u uni) (u1 uni)) (= (Cons_proj_2 a2 (Cons a2 u u1)) u1))))

(declare-fun t2tb1 (a) uni)

;; t2tb_sort
  (assert (forall ((x a)) (sort a1 (t2tb1 x))))

(declare-fun tb2t1 (uni) a)

;; BridgeL
  (assert (forall ((i a)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort a1 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1 (tb2t1 j))) )))

;; liste_inversion
  (assert
  (forall ((u (liste a)))
  (or (= u Nil1)
  (= u (tb2t (Cons a1 (Cons_proj_1 a1 (t2tb u)) (Cons_proj_2 a1 (t2tb u))))))))

;; liste_inversion
  (assert
  (forall ((a2 ty))
  (forall ((u uni))
  (or (= u (Nil a2)) (= u (Cons a2 (Cons_proj_1 a2 u) (Cons_proj_2 a2 u)))))))

(declare-fun append (ty uni uni) uni)

;; append_sort
  (assert
  (forall ((a2 ty))
  (forall ((x uni) (x1 uni)) (sort (liste1 a2) (append a2 x x1)))))

(declare-fun append1 ((liste a) (liste a)) (liste a))

;; append_def
  (assert
  (forall ((l2 (liste a)))
  (and (= (append1 Nil1 l2) l2)
  (forall ((t a) (q (liste a)))
  (= (append1 (tb2t (Cons a1 (t2tb1 t) (t2tb q))) l2) (tb2t
                                                      (Cons a1 (t2tb1 t)
                                                      (t2tb (append1 q l2)))))))))

;; append_def
  (assert
  (forall ((a2 ty))
  (forall ((l2 uni))
  (and (= (append a2 (Nil a2) l2) l2)
  (forall ((t uni) (q uni))
  (= (append a2 (Cons a2 t q) l2) (Cons a2 t (append a2 q l2))))))))

(assert
;; append_Nil_left
 ;; File "induction_etu.mlw", line 13, characters 6-21
  (not (forall ((l (liste a))) (= (append1 Nil1 l) l))))
(check-sat)
